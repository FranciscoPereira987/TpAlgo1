abrir_archivos,(l_ar_entrada),mezcla,    l_manejadores = [],    for ruta in l_ar_entrada:,        l_manejadores.append(open(ruta/ "r")),    return l_manejadores
agregar_separador,(texto),reuti_codigo,    cantidad = texto.find('\n'),    texto += '_' * cantidad + '\n',    return texto
analizar_codigo,(codigo/ diccionario/ nombre_funcion),reuti_codigo,    for linea in codigo:,            revisar_llamadas(diccionario/ linea/ nombre_funcion)
armar_diccionario,(lista_funciones),reuti_codigo,    diccionario = {} ,    for nombre_funcion in lista_funciones:,        diccionario[nombre_funcion] = generar_dicc_ceros(lista_funciones),    return diccionario
armar_lista,(archivo_codigo),reuti_codigo,    lista_funciones = [],    linea = leer_linea_archivo(archivo_codigo) ,    while linea != ['']:,        funcion = f'{linea[0]}.{linea[2]}',        if funcion not in lista_funciones:                                ,            lista_funciones += [funcion],        linea = leer_linea_archivo(archivo_codigo),    archivo_codigo.seek(0),    return lista_funciones
cerrar_archivos,(archivos),mezcla,    for archivo in archivos:,        archivo.close()
contar_llamadas,(dicc_funciones),reuti_codigo,    indice = 0,    lista_llamadas = [0] * len(dicc_funciones),    for funcion in dicc_funciones.keys():,        for funcion_que_llama in dicc_funciones.keys():,            if dicc_funciones[funcion][funcion_que_llama] == 'X':,                lista_llamadas[indice] += int(dicc_funciones[funcion_que_llama][funcion]),        lista_llamadas[indice] = str(lista_llamadas[indice]),        indice += 1,    return lista_llamadas
devolver_clave_minima,(lista/ pos_clave),mezcla,    return min([(pos/ linea[pos_clave]) for pos/ linea in enumerate(lista) \
devolver_parametros,(linea),str_hnd,    indice_inicio = linea.find('('),    ultimo_indice = linea.find(')') + 1,    parametros = procesar_comas(linea[indice_inicio:ultimo_indice]),    return parametros
escribir_archivo,(dicc_funciones/ espacios_columna/ cant_filas),reuti_codigo,    archivo = open("analizador.txt"/ 'w'),    i = 1,    fila_n = generar_primera_fila(len(dicc_funciones)/ espacios_columna),    ultima = generar_ultima_fila(dicc_funciones/ espacios_columna/ cant_filas),    for clave in dicc_funciones:,        archivo.write(fila_n),        fila_n = escribir_funcion(clave/ i/ dicc_funciones[clave]/ espacios_columna/ cant_filas),        i += 1,    archivo.write(fila_n),    archivo.write(ultima),    archivo.close()
escribir_funcion,(nombre_funcion/ numero_funcion/ dicc_funcion/ espacios_columna/ cant_filas),reuti_codigo,    valores_numericos = dicc_funcion.values(),    vacia = [' '] * len(valores_numericos) ,    texto_funcion = f"{numero_funcion}-{nombre_funcion}" ,    total = "",    for i in range(cant_filas):,        if i >= (cant_filas // 2) and texto_funcion:,            fila/ texto_funcion = generar_fila_total(texto_funcion/ espacios_columna/ valores_numericos),            valores_numericos = vacia ,        else:,            fila/ texto_vacio = generar_fila_total(''/ espacios_columna/ vacia),        total += fila,    total = agregar_separador(total),    return total
fin_funcion,(linea),sep_cod_com,
funciones_que_llaman,(dicc_funciones),reuti_codigo,    for funcion in dicc_funciones.keys():,        for funcion_que_llama in dicc_funciones.keys():,            valor = dicc_funciones[funcion_que_llama][funcion],            if valor != 0 and valor != 'X':,                dicc_funciones[funcion][funcion_que_llama] = 'X'
generar_analizador,(),reuti_codigo,    archivo_codigo = open('salida_codigo.csv'/ 'r'),    funciones = armar_lista(archivo_codigo),    funciones = armar_diccionario(funciones),    generar_puntajes(archivo_codigo/ funciones),    funciones_que_llaman(funciones),    escribir_archivo(funciones/ 20/ 5),    os.startfile('analizador.txt')
generar_dicc_ceros,(lista_funciones),reuti_codigo,    dicc_ceros = {},    for funcion in lista_funciones:,        dicc_ceros[funcion] = 0,    return dicc_ceros
generar_fila_numerica,(espacios_columna/ a_escribir),reuti_codigo,    fila = "",    for elemento in a_escribir:,        elemento = (espacios_columna//2) * ' ' + str(elemento),        columna/ texto_vacio = generar_texto_encolumnado(espacios_columna/ elemento),        fila += columna,    return fila + '\n'
generar_fila_total,(texto/ espacios_columna/ valores_numericos),reuti_codigo,    fila/ texto = generar_texto_encolumnado(espacios_columna/ texto),    fila += generar_fila_numerica(espacios_columna // 4/ valores_numericos),    return fila/ texto
generar_primera_fila,(cant_funciones/ espacios_columna),reuti_codigo,    numeros = list(range(1/ cant_funciones + 1)),    vacia = [' '] * cant_funciones,    texto = "",    fila/ texto_vacio = generar_fila_total(""/ espacios_columna/ vacia),    texto += fila,    fila/ texto_vacio = generar_fila_total("FUNCIONES"/ espacios_columna/ numeros),    texto += fila,    fila/ texto_vacio = generar_fila_total(""/ espacios_columna/ vacia),    texto += fila,    texto = agregar_separador(texto),    return texto
generar_puntajes,(archivo_codigo/ diccionario),reuti_codigo,    linea = leer_linea_archivo(archivo_codigo),    while linea != ['']:,        funcion = f'{linea[0]}.{linea[2]}',        analizar_codigo(linea[3:]/ diccionario/ funcion),        linea = leer_linea_archivo(archivo_codigo)
generar_texto_encolumnado,(ancho_columna/ texto),reuti_codigo,    longitud_texto = len(texto),    if longitud_texto > ancho_columna:,        columna = texto[:ancho_columna] + '|',        texto = texto[ancho_columna:],    else:,        espacios = " " * (ancho_columna - longitud_texto) + '|',        columna = texto + espacios,        texto = "",    return columna/ texto
generar_ultima_fila,(dicc_funciones/ espacios_columna/ cant_filas),reuti_codigo,    fila/ texto  = generar_texto_encolumnado(espacios_columna/ "Total invocaciones"),    while texto:,        a_agregar/ texto = generar_texto_encolumnado(espacios_columna/ texto),        fila += a_agregar,    lista_llamadas = contar_llamadas(dicc_funciones),    fila += generar_fila_numerica(espacios_columna // 4/ lista_llamadas),    return fila
identificar_alfabeticamente,(nombre_actual/ nombre_maximo/ nombre_minimo),str_hnd,    return nombre_actual < nombre_maximo and nombre_actual > nombre_minimo
identificar_comentarios,(linea/ comentado_multi),sep_cod_com,    comentarios = '',    forma_de_comentar = '',    if chr(35) in linea: ,        comentarios = comentarios + linea[linea.find(chr(35)) + 1:],        linea = linea[:linea.find(chr(35))],    elif linea.count("\"\"\"") == 1:  ,        comentado_multi = not comentado_multi  ,        forma_de_comentar = "\"\"\"",    elif linea.count("\'\'\'") == 1:,        comentado_multi = not comentado_multi  ,        forma_de_comentar = "\'\'\'",    return linea/ comentado_multi/ comentarios/ forma_de_comentar
identificar_funciones,(linea),str_hnd,    return "def " in linea
ingresar_opcion,(funciones),consulta_funciones,    opcion = input("FunciÃ³n: "),    while opcion!='':,        opcion_elegida/nombre_funcion = validar_opcion(opcion),        if opcion_elegida:,            encontrado/ nombre_encontrado = validar_nombre_funcion(nombre_funcion/ funciones),            if encontrado:,                print("Aca muestro las cosas"),            else:,                print("La funcion es incorrecta"),        else:,            print("opcion invalida"),        opcion = input("Funcion: "),    return opcion
lector_rutas,(archivo_rutas/ ruta_py = False),ordenamiento,    ruta = archivo_rutas.readline(),    if ruta:,        if ruta_py:,            modulo = str_hnd.nombre_modulo(ruta),        else:,            modulo = "",        ruta = ruta.rstrip('\n'),        archivo = open(ruta/ 'r'),    else:,        archivo = modulo = "",    return archivo/ modulo
leer_archivos,(l_manejadores),mezcla,    l_lineas = [],    for manejador in l_manejadores:,        l_lineas.append(manejador.readline().rstrip('\n').split('/')),    return l_lineas
leer_funcion,(archivo),sep_cod_com,    l_lineas = [],    l_comentarios = [],    comentado_multi = False ,    fin = False,    linea/ comentado_multi/ comentarios/ forma_de_comentar = leer_linea(archivo/ comentado_multi),    while not fin and linea:,        if linea.rstrip() != "" and not comentado_multi: ,            l_lineas.append(linea.strip('\n')),        elif comentado_multi:,            comentarios = linea ,            linea = archivo.readline() ,            while forma_de_comentar  not in linea:,                comentarios = comentarios + linea ,                linea = archivo.readline(),                linea = linea.rstrip('\n'),            comentarios = comentarios + linea ,            comentado_multi = False ,        if comentarios != "": ,            l_comentarios.append(comentarios.strip('\n')),        linea/ comentado_multi/ comentarios/ forma_de_comentar = leer_linea(archivo/ comentado_multi),        fin = fin_funcion(linea),    if "return " in linea:,        l_lineas.append(linea.strip('\n')),    return linea/ l_lineas/ l_comentarios 
leer_linea,(archivo/ comentado_multi),sep_cod_com,    linea = archivo.readline(),    linea/ comentado_multi/ comentarios/ forma_de_comentar = \,    identificar_comentarios(linea/ comentado_multi),    return linea/ comentado_multi/ comentarios/ forma_de_comentar
leer_linea_archivo,(archivo),reuti_codigo,    return mezcla.leer_archivos([archivo])[0]
lista_a_string,(l_codigo/ l_comentarios),str_hnd,    str_codigo = '/'.join(l_codigo),    str_comentarios = '/'.join(l_comentarios),    return str_codigo/ str_comentarios
listar_funciones,(),consulta_funciones,    archivo_codigo = open('salida_codigo.csv'/'r'),    funciones = reuti_codigo.armar_lista(archivo_codigo),    numero=0,    while len(funciones)>numero:,        texto='',        for i in range(0/2):,            columnas=reuti_codigo.generar_texto_encolumnado(40/funciones[numero]),            texto=texto+columnas[0],            numero+=1,        print (texto),    archivo_codigo.close(),    return(funciones)
main_ordenamiento,(),ordenamiento,    rutas  = open("programas.txt"/ 'r'),    rutas_comentarios/ rutas_codigo = manejar_archivos(rutas),    rutas.seek(0),    archivo_rutas/ nombre_modulo = lector_rutas(rutas/ True),    while archivo_rutas:,        procesar_entrada(archivo_rutas/ rutas_codigo/ rutas_comentarios/ nombre_modulo),        archivo_rutas/ nombre_modulo = lector_rutas(rutas/ True),    mezcla.cerrar_archivos([rutas/ rutas_codigo/ rutas_comentarios]),    return ["rutas_comentarios.csv"/ "rutas_codigo.csv"]
main_prueba,(),ordenamiento,    archivo_rutas = open("programas.txt"/ 'r'),    archivo_prueba/ modulo = lector_rutas(archivo_rutas/ True),    numero = 0,    while archivo_prueba:,        archivo_salida_com = open(f"comentarios{numero}.csv"/ 'w'),        archivo_salida_cod = open(f"codigo{numero}.csv"/ 'w'),        ordenar_funciones(archivo_prueba/ archivo_salida_cod/ archivo_salida_com/ modulo),        mezcla.cerrar_archivos([archivo_prueba/archivo_salida_cod/ archivo_salida_com]),        archivo_prueba/ modulo = lector_rutas(archivo_rutas/ True),        numero += 1
main_reuti,(),reuti_codigo,    archivo_codigo = open('salidaPrueba0.csv'/ 'r'),    lista_funciones = armar_lista(archivo_codigo),    dicc_funciones = armar_diccionario(lista_funciones),    archivo_codigo.seek(0),    generar_puntajes(archivo_codigo/ dicc_funciones),    funciones_que_llaman(dicc_funciones),    for funcion in dicc_funciones:,        print(funcion/'-->'/dicc_funciones[funcion]),    archivo_codigo.close(),    escribir_archivo(dicc_funciones/ 20/ 3)
main_sep,(),sep_cod_com,    ruta = input("Ingrese la ruta a un archivo de python:\n"),    linea/ lineas/ comentarios = leer_funcion(ruta),    print("Estos son lineas de codigo"),    for i in lineas:,        print(i),    print("Estos son comentarios")    ,    for i in comentarios:,        print(i),    print(lineas/comentarios)
manejar_archivos,(archivo_rutas),ordenamiento,    numero = 0,    ruta = archivo_rutas.readline(),    rutas_comentarios = open("rutas_comentarios.txt"/ 'w'),    rutas_codigo = open("rutas_codigo.txt"/ 'w'),    while ruta:,        rutas_comentarios.write(f"comentarios_{numero}.csv\n"),        rutas_codigo.write(f"codigo_{numero}.csv\n"),        numero += 1,        ruta = archivo_rutas.readline(),    mezcla.cerrar_archivos([rutas_comentarios/ rutas_codigo]),    return open("rutas_comentarios.txt"/ 'r')/ open("rutas_codigo.txt"/ 'r')
mezclar_archivos,(l_ar_entrada/ t_ar_salida/ clave_pos),mezcla,    l_manejadores = abrir_archivos(l_ar_entrada),    l_lineas = leer_archivos(l_manejadores),    pos_min/ l_min = devolver_clave_minima(l_lineas/ 0),    ar_salida = open(t_ar_salida/ "w"),    while pos_min != -1:,        ar_salida.write("/".join(l_lineas[pos_min]) + "\n"),        l_lineas[pos_min] = l_manejadores[pos_min].readline().rstrip('\n').split("/"),        pos_min/ l_min = devolver_clave_minima(l_lineas/ 0),    cerrar_archivos(l_manejadores + [ar_salida])
nombre_funcion,(linea),str_hnd,    indice_max = linea.find("("),    indice_min = linea.find(" ") + 1,    nombre = linea[indice_min:indice_max],    return nombre
nombre_modulo,(linea),str_hnd,    ultimo_indice = linea.find(".py"),    if os.name == "nt":,        primer_indice = len(linea) - linea[::-1].find("\\"),    else:,        primer_indice = len(linea) - linea[::-1].find("/"),    return linea[primer_indice:ultimo_indice]
ordenar_funciones,(archivo_entrada/ archivo_salida_cod/ archivo_salida_com/ nombre_modulo),ordenamiento,    nombre_anterior = 'aaaaaaaa',    nombre_anterior/ parametros/ l_cod/ l_com =\,    recorrer_archivo(archivo_entrada/ nombre_anterior),    while nombre_anterior != MAX_NOMBRE:,        l_cod/ l_com = str_hnd.procesar_funcion(l_cod/ l_com),        linea_cod = f"{nombre_anterior}/{parametros}/{nombre_modulo}/{l_cod}\n",        linea_com = f"{nombre_anterior}/{l_com}\n",        archivo_salida_cod.write(linea_cod),        archivo_salida_com.write(linea_com),        nombre_anterior/ parametros/ l_cod/ l_com = \,        recorrer_archivo(archivo_entrada/ nombre_anterior)
procesar_codigo,(l_codigo),str_hnd,    for i in range(0/ len(l_codigo)):,        l_codigo[i] = procesar_comas(l_codigo[i])
procesar_comas,(texto),str_hnd,    texto = texto.replace('/'/ '/'),    return texto
procesar_comentarios,(l_comentarios),str_hnd,    l_comentarios[0] = procesar_multilinea(l_comentarios[0]),    for i in range(1/ len(l_comentarios)):,        l_comentarios[i] = procesar_comas(l_comentarios[i])
procesar_entrada,(archivo_entrada/ rutas_codigo/ rutas_com/ nombre_modulo),ordenamiento,    archivo_comentarios/ mod_false = lector_rutas(rutas_com),    archivo_codigo/ mod_false = lector_rutas(rutas_codigo) ,    ordenar_funciones(archivo_entrada/ archivo_codigo/ archivo_comentarios/ nombre_modulo),    mezcla.cerrar_archivos([archivo_codigo/ archivo_comentarios])
procesar_funcion,(l_codigo/ l_comentarios),str_hnd,    if l_codigo:,        procesar_codigo(l_codigo),    if l_comentarios:,        procesar_comentarios(l_comentarios),    codigo/ comentarios = lista_a_string(l_codigo/ l_comentarios),    return codigo/ comentarios
procesar_multilinea,(comentario),str_hnd,    if '\n' not in comentario:,        campos = '//' + comentario,    else:,        comentario = comentario.replace('\n'/ ""),        autor = procesar_comas(separar_campo(comentario/ 'autor')),        ayuda = procesar_comas(separar_campo(comentario/ 'ayuda')),        campos = f'{autor}/{ayuda}',    return campos
recorrer_archivo,(archivo_entrada/ nombre_anterior),ordenamiento,    linea = archivo_entrada.readline(),    nombre_maximo = MAX_NOMBRE,    parametros = l_cod = l_com = '',    while linea:,        if str_hnd.identificar_funciones(linea):,            nombre = str_hnd.nombre_funcion(linea),            if str_hnd.identificar_alfabeticamente(nombre/ nombre_maximo/ nombre_anterior):,                parametros = str_hnd.devolver_parametros(linea),                linea/ l_cod/ l_com = sep_cod_com.leer_funcion(archivo_entrada) ,                nombre_maximo = nombre,            else:,                linea = archivo_entrada.readline(),        else:,            linea = archivo_entrada.readline(),    archivo_entrada.seek(0),    return nombre_maximo/ parametros/ l_cod/ l_com 
revisar_llamadas,(diccionario_funciones/ linea/ nombre_funcion_actual),reuti_codigo,    claves = list(diccionario_funciones.keys()),    indice = 1,    indice_punto = claves[0].find('.'),    funcion = claves[0][:indice_punto] ,    while (funcion not in linea) and indice < (len(claves)):,        indice_punto = claves[indice].find('.') ,        funcion = claves[indice][:indice_punto],        indice += 1,    if funcion in linea:,        funcion = (claves[indice-1]),        diccionario_funciones[nombre_funcion_actual][funcion] += 1
separar_campo,(comentario/ campo),str_hnd,    if campo not in comentario.lower():,        devolver = '',    else:,        indice_inicio = (comentario.lower()).find(campo),        indice_final = indice_inicio + (comentario[indice_inicio:]).find(']'),        devolver = comentario[indice_inicio:indice_final],    return devolver
validar_nombre_funcion,(nombre_funcion/l_funciones),consulta_funciones,    posicion = 0,    encontrado = False,    nombre_encontrado='',    while posicion < len(l_funciones) and not encontrado:,        if l_funciones[posicion] == nombre_funcion:,            encontrado = True,            nombre_encontrado=l_funciones[posicion],        posicion+=1,    return encontrado/nombre_encontrado    
validar_opcion,(opcion),consulta_funciones,    valido = False,    nombre_funcion = '',    if opcion[-1] == '?' or opcion[-1] == ',        valido = True,        nombre_funcion = opcion[:-1],    elif opcion[-5:] == '?todo' or opcion[-5:] == ',        valido = True,        nombre_funcion = opcion[:-5],    elif opcion[-14:] ==  'imprimir ?todo':,        valido = True,        nombre_funcion = opcion[:-14],    return valido/nombre_funcion
